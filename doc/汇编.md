```txt
r 查看CPU寄存器的内容
d 查看内存中的内容 d 0000:0000
e 修改内存中的内容 e 0000:0000 修改内存中内容 修改后可按空格修改下一个字节
u 翻译内存中的机器指令 u 073f:0000
t 执行一条机器指令
a 通过汇编指令的格式在内存中写入一条机器指令

add 相加
sub 相减
mov 移动
mul 乘法 两个数相乘，要不都是8位，要么都是16位，如果是八位，一个默认放在AL中，另一个放在8位的内存单元中，如果是16位，一个默认在AX中，另一个放在16位内存单元中。乘法结果：8位乘法，结果放在AX中，如果是16位，高位放在DX中，低位放在AX中

mov al,64  这是16进制的100
mov bl,a   这是16进制的10
mul bl     相乘
结果为 ax=03e8

mov ax,64      16进制的100
mov bx,2710    16进制的10000
mul bx         相乘
结果为 ax 4240  dx 000F

div 除法
一个数除以另一个数，前面的数是被除数，后面的数是除数
如果除数为8位，被除数则为16位，默认在AX中存放被除数，如果除数为16位，被除数则为32位，在DX中存放高16位，AX中存放低16位
除法结果，如果除数为8位，则AL存储商，AH存储余数，如果除数是16位，则AX存储商，DX存储余数

mov ax,2710
mov bl,64
div bl
结果为ax 0064

mov ax,4240
mov dx,000f
mov bx,2710
div bx
结果为 ax2710 dx 0000

and 与运算 都为1则结果为1
or  或运算 有1则结果为1

shl 逻辑左移   
mov al, 01001000b
逻辑左移shl 1
结果10010000
SAL 算数左移

ROL 循环左移
mov al,88   10001000
rol al,1    00010001

shr 逻辑右移
ror 循环右移

inc 加一
dec 减一

nop 什么都不做

xchg 交换值
r ax 1
r bx 2
xchg ax, bx 结果为ax 2, bx 1

neg 求补，取反后加一
r ax 0001
neg ax结果为ffff，0001取反fffe加一ffff

物理地址=段地址乘以16+偏移地址

DS寄存器为数据段地址寄存器
首先设置DS段地址
指令mov al,[0]的意思为将DS段地址+0的偏移地址的数据放入al中
r ds 1000 或者 先mov bx 1000, 然后mov ds,bx
e 1000:000 12 34 56 78
a mov ax,[1] 结果为ax 为3412

数据运算
add bh,[1] 的 意思为取ds为段地址偏移量为1的数据与bh相加

在内存中1234，1的指针小，4的指针大，存储时，指针大的放在高位，指针小的放在低位，因此表现为3412

CS和IP，CS+IP即为EIP，即为代码执行位置,cs为代码段寄存器(段地址)，IP为指令指针寄存器(偏移地址)
可通过r cs r ip 修改当前执行位置

a 2000:0000
mov ax,0123
mov bx,0003
mov ax,bx
add ax,bx
接下来修改cs和IP值指向2000:0000，即可接着按t执行指令

jmp 1000:3 跳转到段地址为1000偏移地址为3的位置

r ax 0000
jmp ax 即跳转为当前段地址偏移地址为0的位置

push 入栈
pop 出栈

ss:sp 寄存器 指向栈顶元素同ESP,ss为段地址，SP为偏移地址
首先指定ss:sp地址
mov ax,1111
push ax
pop ax

[]方括号为取偏移地址
r ds 1000
mov bx, 0
e 1000:0000 ab cd ef
mov ax, [bx] 结果为将段地址为1000偏移地址为0的数据移动给ax，cdab
或 mov ax, [bx+1],但是bx+ax就报错
在中括号中只能写bx,si,di或bx+si,bx+di或bx+si+1,bx+di+1
bp和bx一样，区别为当使用bp时，如果指令中没有明显的给出段地址，段地址使用ss中的地址,bx使用的段地址为ds

es附加段寄存器

标志寄存器
ZF 标记是否为0
PF 奇偶标志 看二进制中的1的个数，为偶数为真
SF 符号标志位
CF 进位借位标志
OF 溢出

adc带进位加法
mov ax,1
mov bx,2
sub ax,bx 此时有借位,cf标志位1，结果为ax ffff,bx 2
adb bx 结果为4

sbb带进位减法

cmp比较指令 影响z标志位，相等时z为1，不相等时z为0
je 等于  Z标志位1
jne 不等于 Z标志位0
jb 低于 C标志位1
jnb 不低于 C标志位0
ja 高于 C标志位0并且Z标志位0
jna 不高于 C标志位1并且Z标志位1

loop 循环
命令g加偏移地址可跳出循环
命令p在即将loop时可跳过循环

BYTE, db, 8位, 字节
WORD, dw, 16位, 字
DWORD, dd, 32位, 双字
QWORD, dq, 64位

jmp short s 需要计算偏移量
jmp far ptr s 直接跳转到相应的地址上
jcxz 条件跳转 

```
#### 编译汇编程序
```txt
masm code.asm
link code.obj
debug code.exe
```
#### 加法程序
```x86asm
assume cs:codesg
codesg segment
	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	mov ax,4c00H
	int 21H
codesg ends
end
```
#### 循环程序
```x86asm
assume cs:codesg
codesg segment
	mov ax,2
	; 如果cx为0则为死循环
	mov cx,11
	s:
	add ax,ax
	loop s
	int 21H
codesg ends
end
```
#### 函数call
```x86asm
assume cs:codesg
codesg segment
    ; 如果使用call far prt和retf 则会向栈内保存ss+ip的地址
	mov ax,2
	; 如果cx为0则为死循环
	mov cx,11
	; 调用函数,会将下一条语句的地址压栈将IP压栈，当执行到ret时，弹栈到IP
	call s
	; 退出
	int 21H
	s:
	add ax,ax
	; 循环
	loop s
	; 返回
	ret
codesg ends
end
```
#### 在代码段中存储数据
```x86asm
assume cs:codesg
codesg segment
	; 数据
	dw 123H,456H,0abcH,0defH ; 在代码段中存储数据
	; 代码开始
	start:
	mov ax,2
	; 如果cx为0则为死循环
	mov cx,11
	; 调用函数
	call s
	; 退出
	int 21H
	s:
	add ax,ax
	; 循环
	loop s
	; 返回
	ret
codesg ends
; 代码结束
end start
end
```
#### 将数据，代码，栈放入不同的段
```x86asm
assume cs:codesg,ds:data,ss:stack
	; 数据段
	data segment
		db 'hello world'
		dw 123h,456h,789h
	data ends
	;栈段
	stack segment
		db 10 dup(0)
	stack ends
	;代码段
	codesg segment
		start:
			mov ax,2
			mov cx,11
			call s
			int 21H
			s:
				add ax,ax
				loop s
				ret
	codesg ends
end start
```
#### offset 偏移量
```x86asm
assume cs:codesg
	;代码段
	codesg segment
		start:
			mov ax,offset start ;这条语句的偏移地址为0000,因此翻译过来为mov ax,0000
			mov dx,offset s; 这条语句的偏移地址为0006, 因此翻译过来为mov dx,0006
			s: 
				mov bx,cx
				inc bx
	codesg ends
end start

```
#### jmp 跳转
```x86asm
assume cs:codesg
	;代码段
	codesg segment
		start:
			mov ax,0
			jmp short s ; 跳转到inc ax处
			add ax,1
			s: 
				inc ax
	codesg ends
end start
```
#### 数组
```x86asm
assume cs:codesg,ds:data,ss:stack
data segment
	arr db 12H,34H ; 数组
	arr2 db 'hello world' ; 数组
data ends
stack segment
	db 10 dup (0)
stack ends
codesg segment
	;arr dw 12,34 ; 数组
	;arr2 db 'hello world' ; 数组
	start:
		mov ax,data ; 这两段代码是将数据段地址和ds联系到一起
		mov ds,ax
		;mov ax,offset arr ; 查看偏移量
		mov al,arr[0];
		mov arr2[0], al ;将al的值赋值给arr2[0], 用于修改数组
codesg ends
end start
```
#### 输出Hello world
```x86asm
assume cs:codesg,ds:data,ss:stack
data segment
	arr2 db 'hello world','$' ; 数组
data ends
stack segment
	db 10 dup (0)
stack ends
codesg segment
	start:
		mov ax,data
		mov ds,ax
		mov dx,offset arr2
		mov ah,9
		int 21H
		mov ah,4cH
		int 21H
codesg ends
end start
```
#### 小写转大写
```x86asm
assume cs:codesg,ds:data,ss:stack
data segment
	arr2 db 'hEllo wOrld','$' ; 数组
data ends
stack segment
	db 10 dup (0)
stack ends
codesg segment
	start:
		mov ax,data
		mov ds,ax
		
		mov bx,0 ; i
		mov cx,11 ; 循环次数
		s:
			mov al,arr2[bx]
			and al,1011111B ; 转大写 如果转小写则为or 100000B
			mov [bx],al
			inc bx
			loop s
		
		mov dx, offset arr2 ; 找到字符串的偏移地址
		mov ah,9
		int 21H
		mov ah,4cH
		int 21H
codesg ends
end start

```

#### 求最大值
```x86asm
assume cs:codesg,ds:data,ss:stack
data segment
	arr2 db 'hello world','$' ; 数组
data ends
stack segment
	db 10 dup (0)
stack ends
codesg segment
	start:
		mov ax,data
		mov ds,ax
		
		mov bx,0 ; i
		mov cx,11 ; 循环次数
		mov ah,0 ; 定义ah的值为0
		s:
			mov al,arr2[bx]
			cmp ah, al
			ja s1 ; ja是大于，符合条件跳转
			mov ah,al
		s1:
			mov arr2[bx], al
			inc bx
			loop s
		
		mov dx, offset arr2 ; 找到字符串的偏移地址
		mov ah,9
		int 21H
		mov ah,4cH
		int 21H
codesg ends
end start

```

