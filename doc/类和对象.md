#### 类的访问权限
```txt
公共权限 public 成员 类内可以访问, 类外也可以访问
保护权限 protected 成员 类内可以访问, 类外不能访问, 子类可以访问父类中保护的内容
私有权限 private 成员 类内可以访问, 类外不能访问, 子类不能访问父类中保护的内容
```
#### struct权限默认为公共public, class权限默认为私有 private
#### 构造函数和析构函数
```txt
对象的初始化和清理工作是编译器强制我们要做的事情
构造函数：主要作用在创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
析构函数：主要作用在对象销毁前系统自动调用，执行一些清理工作。
```
#### 构造函数
```txt
1、构造函数，没有返回值，也不写void
2、函数名称与类名相同
3、构造函数可以有参数，因此可以发生重载
4、程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次
```
#### 析构函数
```txt
1、析构函数，没有返回值也不写void
2、函数名称与类名相同，在名称前加上~符号
3、析构函数不可以有参数，因此不能发生重载
4、程序在对象销毁前自动调用析构，无需手动调用，而且只会调用一次
```
#### 无参构造函数, 有参构造函数, 拷贝构造函数
#### 创建实例时, 无参构造函数不要写括号
```txt
无参构造
Person p1;
有参构造
Person p2 = Person(10); 或 Person p2(10);
拷贝构造
Person p3 = Person(p2) 或Person p3(p2);
```
```c++
class Person
{
    public:
        int age;
    // 在public权限下
    public:
        // 构造函数, 无参构造
        Person()
        {
            cout << "无参构造函数" << endl;
        }
        // 有参构造
        Person(int age_value)
        {
            age = age_value;
            cout << "有参构造函数" << endl;
        }

        // 拷贝构造函数, const用于限定, 不能修改源, 将传入的人身上所有的属性, 拷贝到自己身上
        Person(const Person &p)
        {
            age = p.age;
            cout << "拷贝构造函数" << endl;
        }

        // 析构函数
        ~Person()
        {
            cout << "析构函数" << endl;
        }
};

void test()
{
    // Person p; // 无参构造函数不能写括号
    // Person p1(10);
    // cout << "p1的年龄为" << p1.age << endl;
    // // Person p2 = Person(p1);
    // Person p2(p1);
    // cout << "p2的年龄为" << p2.age << endl;
    // 匿名对象
    Person(10);
}

int main()
{
    test();
    // Person p;
    // system("read");
}
```
#### 如果自定义了有参构造函数, 编译器将不提供无参构造函数, 但依然提供拷贝构造函数
#### 如果自定义了拷贝构造函数, 编译器将不提供默认构造函数(无参, 有参)
#### 深拷贝和浅拷贝
```txt
浅拷贝：拷贝构造函数中的赋值拷贝操作
深拷贝：在堆区重新申请空间, 进行拷贝工作
```
#### 静态成员变量
```txt
1、所有对象都共享同一份数据, 一处修改, 所有地方都变
2、编译阶段就分配内存, 分配在全局区
3、类内声明, 类外初始化操作
4、静态成员变量也受权限控制, private类外不可访问
```
#### 静态成员函数
```txt
1、所有对象共享同一个函数
2、静态成员函数只能访问静态成员变量
3、静态成员函数也受权限控制, private类外不可访问
4、不能在静态方法中修改类成员变量, 编译器不知道到底要修改哪个实例的数据
```
#### this指针指向被调用的成员函数所属的对象
#### 继承中先调用父类的构造方法, 后调用子类的, 先调用子类的析构, 后调用父类的析构.
#### 多态
```txt
1、有继承关系
2、子类重写父类中的虚函数
3、父类指针或引用指向子类对象
```
#### 抽象类, 抽象类不能实例化, 子类必须重写抽象类中的 纯虚函数