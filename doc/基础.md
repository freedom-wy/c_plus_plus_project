#### 前置递增为先递增后进行运算, 即10先加1, 然后进行乘法运算, 后置递增为先进行乘法运算后加一
#### 数组就是一个集合, 里面存放了相同类型的数据元素, 数组是由连续的内存位置组成的
#### 定义常量, 在文件的上方通过#define来进行定义宏常量或通过const来修饰变量, 定义后不可修改
```c
#define MAX 100 // 定义常量时不写后面的分号
```
#### 值传递时，函数的形参发生改变，但不会影响实参
#### 可以通过函数的声明告诉编译器有函数存在,即可以不写函数体,将函数体定义在main函数的下面
#### cout << 左输出 cin >> 右输入, 在C语言中printf等函数输出, scanf等函数输入
#### 三目运算符
```c++
int a = 1;
int b = 2;
int c = 0;
c = (a > b ? a :b);
cout << "c的值为: " << c << endl;
```
#### 指针占用的内存空间,32位操作系统占用4个字节, 64位操作系统占用8个字节, 与类型无关
#### 空指针: 指针变量指向内存中编号为0的空间, 空指针用于初始化指针变量, 空指针不能访问
#### 万能指针: void * 可以保存任意的数据类型的地址 
```c
 void test7()
 {
    void * p = NULL;
    int num = 10;
    p = &num;
    // 输出数据前需强转为int *, 否则无法解引用
    printf("输出指针中保存的数据: %d\n", *(int*)p);
 }
```
#### 常量指针, 指针的指向可以修改, 值不能修改, const int* p1 = &a; 修饰的是*
#### 指针常量 指针的指向不可以修改, 值可以修改, int* const p1 = &a; 修饰的是p1
#### const int *const p3 = &x; 指向和值都不能修改
#### 函数形参为指针时, 可以通过传递地址来修改数据
#### C++分文件编写
```c++
// 创建.h后缀名的头文件
// 创建.cpp后缀名的源文件
// 在头文件中写函数的声明
// 在源文件中写函数的定义
```
#### 进制转换
```txt
1、10进制转2进制, 用10进制数除以2, 一直除到0, 取余数, 翻转
2、10进制转8进制, 用10进制数除以8
3、10进制转16进制, 用10进制数除以16
4、2进制转8进制, 将二进制从右向左, 每3位组成一个八进制, 11001100, 11 001 100 八进制为314
5、2进制转16进制, 将二进制从右向左, 每4位组成一个八进制, 1100 1001 十六进制为c9
6、8进制转2进制, 从右向左, 每一位8进制转成3位2进制 0567二进制为 101 110 111
7、16进制转2进制, 从右向左, 每一位16进制转换成4位2进制 0xab二进制为 10101011
```
#### 原码, 反码, 补码
```txt
1、计算机一律使用补码的形式存储数据
原码：15
无符号：15 0000 1111
有符号：+15 0000 1111
有符号：-15 1000 1111

反码：
无符号数字 反码=原码
有符号数字 正数 反码=原码
有符号数字 负数 原码符号位不动，其余位取反 1111 0000

补码：
无符号数字：原码=反码=补码
有符号数字：正数 原码=反码=补码
有符号数字：负数 补码=反码+1 1111 0001
```
#### 加法
```txt
0+0=0，0+1=1 ，1+0=1， 1+1=10
9+(-6)
9 原码：00001001 反码：00001001 补码：00001001
-6 原码：10000110 反码：11111001 补码：11111010
相加：
00001001
11111010
100000011 超出8位，最高位舍去 00000011=3
```
#### 有符号数和无符号数
```txt
有符号数是最高位为符号位，0代表正数，1代表负数
无符号整形，没有正负之分
有符号整形，有正负之分
```
#### 有符号变量和无符号变量 
```c
// 有符号变量 省略了signed
// signed int a = 10;
int a = 10;

// 无符号变量
unsigned int a = 10;
```
#### 浮点型
float 单精度 占用4个字节 精确7位有效数字
double 双精度 占用8个字节 精确15-16位有效数字
#### 字符串 双引号引起的字符串会自带字符串结束的标志 \0, 遇到\0就会结束
#### 字符串即为字符数组 char str[] = "hello world"
#### 数据的输入scanf
#### 区间表示 b>=5 && b<=10 或 a<5 || a>10
#### 类型转换
```c
// 隐式转换
void test4()
{
    // 隐式转换 int转char
    int num = 353; // 转成2进制为9位, 一个ch为1个字节8位, 舍弃最高位, 最终放入的二进制转成10进制为97, 因此输出为a
    char ch = num;
    printf("%c\n", ch);
}

void test5()
{
    // 强制类型转换
    float f = 3.14f;
    int num = 0;
    // num = (int)f; // 强制类型转换
    num = f;
    printf("num的值为: %d\n", num);
}
```
#### 字符串数组
```txt
C语言中没有字符串这种数据类型，可以通过char的数组来替代；
字符串一定是一个char的数组，但char的数组未必是字符串；
数字0(和字符‘\0’等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。
strlen遇到\0就结束
scanf遇到空格会结束
gets(buf) 可以接受中间带空格的, 没有检测越界情况，一旦越界，程序崩溃
puts(buf) 输出字符串 带换行
fgets(buf, sizeof(buf), stdin) 
fputs(buf, stdout); 不带换行
```
```c
void test3()
{
    char buf3[14] = {0};
    fgets(buf3, sizeof(buf3), stdin); // 可以接收空格, 会检测数组越界情况, 越界丢弃
    printf("%s\n", buf3);
}
```
#### 时间戳
```c
#include <time.h>
printf("时间戳为: %d\n", time(NULL));
```
#### 指针
```txt
指针属于数据类型 int *
通过指针类型创建的变量 称为指针变量
通过指针间接的访问内存
指针占用4个字节空间, int* char* double* short* 32位操作系统
指针占用8个字节空间, 64位操作系统
```
#### 指针数组 数组中每一个元素的数据类型为指针
#### 指针运算, 指针相加无意义, 相减为指针间位移
#### 数组做函数名
```c
void test11(int *arr, int arr_len)
{
    printf("数组大小为: %d\n", sizeof(arr));
    for(int i = 0; i < arr_len; i++)
    {
        printf("数组中元素的值为: %d\n", arr[i]);
        // arr++;
    }
}

void test12(int arr[], int arr_len)
{
    printf("数组大小为: %d\n", sizeof(arr));
    for(int i = 0; i < arr_len; i++)
    {
        printf("数组中的元素值为: %d\n", arr[i]);
    }
}
```
#### 字符串和字符数组
```c
void test13()
{ 
    // char str1[5] = {'h', 'e', 'l', 'l', 'o'}; // 不是字符串, 是字符数组, 无论数组是否限定长度, 都不会在后面添加\0
    // printf("str1的值为: %s\n", str1); // 因为str后面没有\0结束符, 因此输出hello后会输出乱码
    // char str2[10] = {'h', 'e', 'l', 'l', 'o'}; // 字符数组, 是字符串, 后面会通过\0补齐
    // printf("str2的值为: %s\n", str2);
    // char str3[2] = "hello world"; // 自动添加\0
    char str3[2] = "hello world"; // 自动添加\0, 如果越界, 会舍弃\0, 造成乱码
    printf("str3的值为: %s\n", str3);

    char* str4 = "hello world"; // 字符常量, 不能修改
    char str5[20] = "hello world"; // 用数组存的字符串, 是变量, 可以修改 
}
```
#### 字符串复制
```c
void test1()
{
    // char dest[20] = {'0'};
    char dest[20]; // 长度需足够, 否则会报错
    char src[] = "hello world"; // 包含\0
    strcpy(dest, src);
    printf("%s\n", dest);
    printf("dest的sizeof值为: %d\n", sizeof(dest));
    printf("dest的strlen的值为: %d\n", strlen(dest));
    for(int i=0; i<sizeof(dest); i++)
    {
        printf("字符值为: %c\n", dest[i]);
    }
}

void test2()
{
    // char dest[20] = {'0'};
    char dest[20]; // 由于未初始化0, 通过strncpy对限定长度拷贝时, 会输出乱码
    char src[] = "hello world";
    strncpy(dest, src, 5);
    printf("%s\n", dest);
    for(int i = 0; i<sizeof(dest); i++)
    {
        printf("字符值为: %c\n", dest[i]);
    }
}
```
#### 字符串比较 strcmp遇到\0对比结束
```c
void test3()
{
    char str1[] = "hello world";
    char str2[] = "hello world";
    // if(str1 == str2) // 字符串不能使用这种方式进行对比, 需要使用strcmp
    // if(strcmp(str1, str2) == 0)
    // {
    //     printf("字符串相等\n");
    // }
    char str3[32] = {'0'};
    fgets(str3, sizeof(str3), stdin); // 输入数据并给str3赋值
    str3[strlen(str3)-1] = '\0'; //处理最后的换行符, 修改为\0
    if (strcmp(str1, str3) == 0) // strncmp 只比较n个字符 strncmp(str1, str2, n)
    {
        printf("输入的字符串相同\n");
    }
    else
    {
        printf("输入的字符串不同\n");
    }
}
```
#### 全局变量
```c
extern int g_a; // 有作用域

void test1()
{
    // extern int g_a; // 只能在test1中使用
    printf("g_a的值为: %d\n", g_a);
}

int main()
{
    // // 声明有一个全局变量, 可以到其他文件中查找, 编译时需多文件编译gcc -o main main.c test.c
    // extern int g_a;
    test1();
    printf("g_a的值为: %d\n", g_a);
    // int a; // 未赋值, 值内容为随机
    // printf("a的值为: %d\n", a);
    return 0;
}
```
#### 静态局部变量
```c
void test3()
{
    // 静态局部变量作用范围{}, 声明周期为程序结束后释放
    static int s_b = 200;
    s_b++;
    printf("s_b的值为: %d\n", s_b);
}
```
#### 静态全局变量 在当前文件中可以使用,不能跨文件 与全局变量的区别是, 全局变量可以在其他文件中使用
#### 指针与数组名的区别
```txt
指针：也是一个变量，存储的数据是地址。

数组名：代表的是该数组最开始的一个元素的地址。

int a[10];
int *p;
p = &a[0] // 可以写成 p = a;
对数组元素 a[i]的引用也可以写成*(a+i)这种形式。
赋值语句  p=&a[0] 也可以写成下列形式: p=a。
p 是个指针，p[i]与*(p+i)是等价的。
区别：指针是一个变量，可以进行数值运算。数组名不是变量，不可以进行数值运算。
```
 
